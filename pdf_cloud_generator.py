#!/usr/bin/env python3
"""
Gerador de PDF compat√≠vel com Google Cloud Platform
Mant√©m o layout original do HTML usando weasyprint
"""

import os
import tempfile
from datetime import datetime

def gerar_pdf_cloud_romaneio(romaneio_data, itens_data, pasta_destino='Romaneios_Separacao', is_reprint=False):
    """
    Fun√ß√£o mantida para compatibilidade (n√£o usada mais)
    """
    pass

def salvar_pdf_cloud(html_content, romaneio_data, pasta_destino=None, is_reprint=False, itens_data=None):
    """
    Converte HTML diretamente para PDF mantendo o layout original
    Usa weasyprint no Cloud Run para manter layout id√™ntico ao HTML
    
    Args:
        html_content: Conte√∫do HTML renderizado
        romaneio_data: Dados do romaneio
        pasta_destino: Pasta de destino (None para usar arquivo tempor√°rio)
        is_reprint: Se √© reimpress√£o
        itens_data: N√£o usado (mantido para compatibilidade)
    """
    try:
        import os
        import tempfile
        
        # Nome do arquivo
        romaneio_id = romaneio_data.get('id_impressao', 'ROM-000001')
        if is_reprint:
            filename = f"{romaneio_id}_Copia.pdf"
        else:
            filename = f"{romaneio_id}.pdf"
        
        # Se pasta_destino for None, usar arquivo tempor√°rio
        if pasta_destino is None:
            temp_dir = tempfile.gettempdir()
            filepath = os.path.join(temp_dir, filename)
        else:
            # Criar pasta se n√£o existir
            os.makedirs(pasta_destino, exist_ok=True)
            filepath = os.path.join(pasta_destino, filename)
        
        # Validar filepath
        if not filepath:
            return {
                'success': False,
                'message': 'Erro: N√£o foi poss√≠vel determinar caminho do arquivo'
            }
        
        print(f"üìÑ Filepath determinado: {filepath}")
        
        # Adicionar marca d'√°gua de c√≥pia se necess√°rio (igual ao pdf_browser_generator)
        if is_reprint:
            # Modificar o t√≠tulo para incluir "C√ìPIA"
            html_content = html_content.replace(
                '<h2>Romaneio de Separa√ß√£o</h2>', 
                '<h2 style="color: red; border: 2px solid red; padding: 10px; background-color: #ffebee;">üìã C√ìPIA - Romaneio de Separa√ß√£o</h2>'
            )
            
            # Modificar o ID do romaneio para incluir "C√ìPIA"
            romaneio_id_split = romaneio_id.split("-")
            if len(romaneio_id_split) > 1:
                html_content = html_content.replace(
                    f'ROM-{romaneio_id_split[-1]}',
                    f'ROM-{romaneio_id_split[-1]} - C√ìPIA'
                )
            
            # Adicionar texto no rodap√© com data de reimpress√£o
            data_reimpressao = romaneio_data.get('data_reimpressao', '')
            if data_reimpressao:
                rodape_texto = f'Sistema v4.0.0 - Romaneios de Separa√ß√£o | ‚ö†Ô∏è DOCUMENTO DE C√ìPIA/REIMPRESS√ÉO<br><strong>Reimpress√£o realizada em: {data_reimpressao}</strong>'
            else:
                rodape_texto = 'Sistema v4.0.0 - Romaneios de Separa√ß√£o | ‚ö†Ô∏è DOCUMENTO DE C√ìPIA/REIMPRESS√ÉO'
            
            html_content = html_content.replace(
                'Sistema v4.0.0 - Romaneios de Separa√ß√£o',
                rodape_texto
            )
        
        # Validar HTML content
        if not html_content or not isinstance(html_content, str):
            return {
                'success': False,
                'message': f'Erro: HTML content inv√°lido (tipo: {type(html_content)})'
            }
        
        print(f"üìÑ HTML content tamanho: {len(html_content)} caracteres")
        
        # Tentar usar weasyprint (funciona no Cloud Run)
        pdf_gerado = False
        try:
            from weasyprint import HTML
            print("üìÑ Convertendo HTML para PDF usando WeasyPrint (mant√©m layout original)...")
            
            # Converter HTML para PDF
            HTML(string=html_content).write_pdf(filepath)
            
            # Verificar se o arquivo foi realmente criado
            if os.path.exists(filepath) and os.path.getsize(filepath) > 0:
                file_size = os.path.getsize(filepath)
                print(f"‚úÖ PDF gerado com layout original: {filepath} ({file_size} bytes)")
                pdf_gerado = True
            else:
                print(f"‚ö†Ô∏è Arquivo PDF n√£o foi criado ou est√° vazio: {filepath}")
            
        except ImportError as ie:
            # Se weasyprint n√£o estiver dispon√≠vel, usar ReportLab como fallback
            print(f"‚ö†Ô∏è WeasyPrint n√£o dispon√≠vel ({ie}), usando ReportLab como fallback...")
            try:
                from reportlab.lib.pagesizes import A4, landscape
                from reportlab.lib.styles import getSampleStyleSheet
                from reportlab.platypus import SimpleDocTemplate
                from reportlab.platypus import Paragraph, Spacer
                
                doc = SimpleDocTemplate(filepath, pagesize=landscape(A4))
                story = []
                styles = getSampleStyleSheet()
                story.append(Paragraph("PDF gerado com layout alternativo (WeasyPrint n√£o dispon√≠vel)", styles['Normal']))
                story.append(Spacer(1, 20))
                story.append(Paragraph("Use weasyprint para manter layout original do HTML", styles['Normal']))
                doc.build(story)
                
                if os.path.exists(filepath) and os.path.getsize(filepath) > 0:
                    pdf_gerado = True
                    print(f"‚úÖ PDF gerado com ReportLab: {filepath}")
            except Exception as rle:
                print(f"‚ùå ERRO ao gerar PDF com ReportLab: {rle}")
                import traceback
                traceback.print_exc()
            
        except Exception as e:
            print(f"‚ùå Erro ao gerar PDF com WeasyPrint: {e}")
            import traceback
            traceback.print_exc()
            return {
                'success': False,
                'message': f'Erro ao gerar PDF: {str(e)}'
            }
        
        # Verificar se o PDF foi gerado
        if not pdf_gerado:
            return {
                'success': False,
                'message': 'Erro: N√£o foi poss√≠vel gerar o PDF (arquivo n√£o foi criado ou est√° vazio)'
            }
        
        # SEMPRE tentar salvar no Cloud Storage
        pdf_result = {
            'success': True,
            'message': 'PDF gerado com layout original',
            'file_path': filepath
        }
        
        print("üîç INICIANDO SALVAMENTO NO CLOUD STORAGE...")
        print(f"üì¶ Vari√°veis: K_SERVICE={os.environ.get('K_SERVICE')}, PORT={os.environ.get('PORT')}")
        
        # Ler o PDF gerado e salvar no Cloud Storage
        try:
            # Verificar se filepath n√£o √© None
            if not filepath:
                error_msg = 'ERRO CR√çTICO: filepath √© None na hora de salvar no Cloud Storage'
                print(f"‚ùå {error_msg}")
                pdf_result['success'] = False
                pdf_result['message'] = error_msg
                return pdf_result
            
            # Verificar se o arquivo existe
            if not os.path.exists(filepath):
                error_msg = f'ERRO CR√çTICO: PDF n√£o encontrado no caminho: {filepath}'
                print(f"‚ùå {error_msg}")
                pdf_result['success'] = False
                pdf_result['message'] = error_msg
                return pdf_result
            
            print(f"üìÑ Lendo PDF do caminho tempor√°rio: {filepath}")
            
            # Ler conte√∫do do PDF
            try:
                with open(filepath, 'rb') as f:
                    pdf_content = f.read()
            except Exception as read_error:
                error_msg = f'ERRO ao ler arquivo PDF: {read_error}'
                print(f"‚ùå {error_msg}")
                import traceback
                traceback.print_exc()
                pdf_result['success'] = False
                pdf_result['message'] = error_msg
                return pdf_result
            
            # Validar conte√∫do do PDF
            if not pdf_content or len(pdf_content) == 0:
                error_msg = 'ERRO: Arquivo PDF est√° vazio'
                print(f"‚ùå {error_msg}")
                pdf_result['success'] = False
                pdf_result['message'] = error_msg
                return pdf_result
                
            if not pdf_content.startswith(b'%PDF'):
                error_msg = f'Arquivo n√£o √© um PDF v√°lido (come√ßa com: {pdf_content[:20]})'
                print(f"‚ö†Ô∏è {error_msg}")
                pdf_result['success'] = False
                pdf_result['message'] = error_msg
                return pdf_result
            
            print(f"üìä Tamanho do PDF: {len(pdf_content)} bytes")
            
            # Deletar arquivo tempor√°rio imediatamente ap√≥s ler
            try:
                os.unlink(filepath)
                print(f"üóëÔ∏è Arquivo tempor√°rio removido: {filepath}")
            except Exception as del_error:
                print(f"‚ö†Ô∏è Aviso: N√£o foi poss√≠vel deletar arquivo tempor√°rio: {del_error}")
            
            # Salvar no Cloud Storage
            from salvar_pdf_gcs import salvar_pdf_gcs
            bucket_name = os.environ.get('GCS_BUCKET_NAME', 'romaneios-separacao')
            print(f"üì¶ Bucket: {bucket_name}")
            print(f"üÜî Romaneio ID: {romaneio_id}")
            print(f"üì§ Chamando salvar_pdf_gcs com {len(pdf_content)} bytes...")
            
            gcs_path = salvar_pdf_gcs(pdf_content, romaneio_id, bucket_name, is_reprint)
            
            if gcs_path:
                print(f"‚úÖ PDF salvo no Cloud Storage: {gcs_path}")
                pdf_result['gcs_path'] = gcs_path
                pdf_result['message'] = 'PDF salvo no Cloud Storage'
            else:
                error_msg = 'Falha ao salvar no Cloud Storage (retornou None)'
                print(f"‚ùå {error_msg}")
                pdf_result['success'] = False
                pdf_result['message'] = error_msg
                
        except Exception as e:
            error_msg = f'ERRO CR√çTICO ao salvar no Cloud Storage: {e}'
            print(f"‚ùå {error_msg}")
            import traceback
            traceback.print_exc()
            pdf_result['success'] = False
            pdf_result['message'] = error_msg
        
        return pdf_result
        
    except Exception as e:
        print(f"‚ùå Erro ao gerar PDF: {e}")
        import traceback
        traceback.print_exc()
        return {
            'success': False,
            'message': f'Erro: {str(e)}'
        }
